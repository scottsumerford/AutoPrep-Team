import "./config";
import postgres from 'postgres';

// Log the connection string being used (without exposing the password)
const connectionString = process.env.POSTGRES_URL;
if (connectionString) {
  const maskedUrl = connectionString.replace(/:([^@]+)@/, ':****@');
  console.log('‚úÖ Database connection string configured:', maskedUrl);
} else {
  console.warn('‚ö†Ô∏è No POSTGRES_URL found - using in-memory storage');
}

// Create postgres client
const sql = connectionString ? postgres(connectionString, {
  max: 10,
  idle_timeout: 20,
  connect_timeout: 10,
}) : null;

export interface Profile {
  id: number;
  name: string;
  email: string;
  url_slug: string;
  title?: string;
  google_access_token?: string;
  google_refresh_token?: string;
  outlook_access_token?: string;
  outlook_refresh_token?: string;
  operation_mode: 'auto-sync' | 'manual';
  manual_email?: string;
  keyword_filter?: string;
  slide_template_url?: string;
  company_info_url?: string;
  created_at: Date;
  updated_at: Date;
}

export interface CalendarEvent {
  id: number;
  profile_id: number;
  event_id: string;
  title: string;
  description?: string;
  start_time: Date;
  end_time: Date;
  attendees?: string[];
  source: 'google' | 'outlook';
  created_at: Date;
}

export interface TokenUsage {
  id: number;
  profile_id: number;
  operation_type: 'agent_run' | 'presales_report' | 'slides_generation';
  tokens_used: number;
  lindy_agent_id?: string;
  created_at: Date;
}

export interface FileUpload {
  id: number;
  profile_id: number;
  file_type: 'slide_template' | 'company_info';
  file_url: string;
  file_name: string;
  created_at: Date;
}

// In-memory storage fallback
let inMemoryProfiles: Profile[] = [];
let inMemoryEvents: CalendarEvent[] = [];
let inMemoryTokens: TokenUsage[] = [];
let inMemoryFiles: FileUpload[] = [];
let nextProfileId = 1;
let nextEventId = 1;
let nextTokenId = 1;
let nextFileId = 1;

// Database initialization
export async function initializeDatabase() {
  if (!sql) {
    console.warn('‚ö†Ô∏è Database not configured, skipping initialization');
    return;
  }

  try {
    console.log('üîß Initializing database tables...');
    
    // Create profiles table with url_slug
    await sql`
      CREATE TABLE IF NOT EXISTS profiles (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        email VARCHAR(255) UNIQUE NOT NULL,
        url_slug VARCHAR(255) UNIQUE NOT NULL,
        title VARCHAR(255),
        google_access_token TEXT,
        google_refresh_token TEXT,
        outlook_access_token TEXT,
        outlook_refresh_token TEXT,
        operation_mode VARCHAR(50) DEFAULT 'manual',
        manual_email VARCHAR(255),
        keyword_filter TEXT,
        slide_template_url TEXT,
        company_info_url TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `;
    console.log('‚úÖ Profiles table ready');

    // Create calendar_events table
    await sql`
      CREATE TABLE IF NOT EXISTS calendar_events (
        id SERIAL PRIMARY KEY,
        profile_id INTEGER REFERENCES profiles(id) ON DELETE CASCADE,
        event_id VARCHAR(255) NOT NULL,
        title VARCHAR(500) NOT NULL,
        description TEXT,
        start_time TIMESTAMP NOT NULL,
        end_time TIMESTAMP NOT NULL,
        attendees JSONB,
        source VARCHAR(50) NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(profile_id, event_id, source)
      )
    `;
    console.log('‚úÖ Calendar events table ready');

    // Create token_usage table
    await sql`
      CREATE TABLE IF NOT EXISTS token_usage (
        id SERIAL PRIMARY KEY,
        profile_id INTEGER REFERENCES profiles(id) ON DELETE CASCADE,
        operation_type VARCHAR(50) NOT NULL,
        tokens_used INTEGER NOT NULL,
        lindy_agent_id VARCHAR(255),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `;
    console.log('‚úÖ Token usage table ready');

    // Create file_uploads table
    await sql`
      CREATE TABLE IF NOT EXISTS file_uploads (
        id SERIAL PRIMARY KEY,
        profile_id INTEGER REFERENCES profiles(id) ON DELETE CASCADE,
        file_type VARCHAR(50) NOT NULL,
        file_url TEXT NOT NULL,
        file_name VARCHAR(255) NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `;
    console.log('‚úÖ File uploads table ready');

    // Create indexes
    await sql`CREATE INDEX IF NOT EXISTS idx_calendar_events_profile ON calendar_events(profile_id)`;
    await sql`CREATE INDEX IF NOT EXISTS idx_calendar_events_start_time ON calendar_events(start_time)`;
    await sql`CREATE INDEX IF NOT EXISTS idx_token_usage_profile ON token_usage(profile_id)`;
    await sql`CREATE INDEX IF NOT EXISTS idx_token_usage_operation ON token_usage(operation_type)`;
    await sql`CREATE INDEX IF NOT EXISTS idx_file_uploads_profile ON file_uploads(profile_id)`;
    console.log('‚úÖ Database indexes created');

    console.log('‚úÖ Database tables initialized successfully');
  } catch (error) {
    console.error('‚ùå Error initializing database:', error);
    throw error;
  }
}

// Profile operations
export async function getAllProfiles(): Promise<Profile[]> {
  if (!sql) {
    console.log('üì¶ Database not configured, using in-memory storage');
    return inMemoryProfiles;
  }

  try {
    console.log('üîç Fetching all profiles from database...');
    const rows = await sql<Profile[]>`SELECT * FROM profiles ORDER BY created_at DESC`;
    console.log(`‚úÖ Successfully fetched ${rows.length} profiles from database`);
    return rows;
  } catch (error) {
    console.error('‚ùå Database error fetching profiles:', error);
    console.log('üì¶ Falling back to in-memory storage');
    return inMemoryProfiles;
  }
}

// Helper function to generate URL slug from name
function generateSlug(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

export async function createProfile(data: Omit<Profile, 'id' | 'created_at' | 'updated_at'>): Promise<Profile> {
  // Generate url_slug if not provided
  const url_slug = data.url_slug || generateSlug(data.name);

  console.log('üìù Creating new profile:', { name: data.name, email: data.email, url_slug });
  
  if (!sql) {
    console.log('üì¶ Database not configured, saving to in-memory storage');
    const newProfile: Profile = {
      url_slug,
      url_slug,
      ...data,
      id: nextProfileId++,
      created_at: new Date(),
      updated_at: new Date(),
    };
    inMemoryProfiles.push(newProfile);
    console.log('‚úÖ Profile created in memory:', newProfile.name);
    return newProfile;
  }

  try {
    console.log('üíæ Inserting profile into database...');
    const [profile] = await sql<Profile[]>`
      INSERT INTO profiles (
        name, email, url_slug, title, operation_mode, manual_email, keyword_filter,
        slide_template_url, company_info_url
      ) VALUES (
        ${data.name}, ${data.email}, ${url_slug}, ${data.title || null},
        ${data.operation_mode || 'manual'}, ${data.manual_email || null},
        ${data.keyword_filter || null}, ${data.slide_template_url || null},
        ${data.company_info_url || null}
      )
      RETURNING *
    `;
    console.log('‚úÖ Profile created successfully in database:', profile.name);
    return profile;
  } catch (error) {
    console.error('‚ùå Database error creating profile:', error);
    console.log('üì¶ Falling back to in-memory storage');
    const newProfile: Profile = {
      url_slug,
      url_slug,
      ...data,
      id: nextProfileId++,
      created_at: new Date(),
      updated_at: new Date(),
    };
    inMemoryProfiles.push(newProfile);
    return newProfile;
  }
}

export async function getProfileById(id: number): Promise<Profile | null> {
  if (!sql) {
    return inMemoryProfiles.find(p => p.id === id) || null;
  }

  try {
    console.log(`üîç Fetching profile by ID: ${id}`);
    const [profile] = await sql<Profile[]>`SELECT * FROM profiles WHERE id = ${id}`;
    if (profile) {
      console.log(`‚úÖ Found profile: ${profile.name}`);
    } else {
      console.log(`‚ùå Profile not found with ID: ${id}`);
    }
    return profile || null;
  } catch (error) {
    console.error('‚ùå Database error fetching profile:', error);
    return inMemoryProfiles.find(p => p.id === id) || null;
  }
}

export async function getProfileBySlug(slug: string): Promise<Profile | null> {
  if (!sql) {
    return inMemoryProfiles.find(p => p.url_slug === slug) || null;
  }

  try {
    console.log(`üîç Fetching profile by slug: ${slug}`);
    const [profile] = await sql<Profile[]>`SELECT * FROM profiles WHERE url_slug = ${slug}`;
    if (profile) {
      console.log(`‚úÖ Found profile: ${profile.name}`);
    } else {
      console.log(`‚ùå Profile not found with slug: ${slug}`);
    }
    return profile || null;
  } catch (error) {
    console.error('‚ùå Database error fetching profile:', error);
    return inMemoryProfiles.find(p => p.url_slug === slug) || null;
  }
}

export async function updateProfile(id: number, data: Partial<Profile>): Promise<Profile | null> {
  console.log(`üìù Updating profile ID ${id}:`, Object.keys(data));
  
  if (!sql) {
    const index = inMemoryProfiles.findIndex(p => p.id === id);
    if (index === -1) return null;
    
    inMemoryProfiles[index] = {
      ...inMemoryProfiles[index],
      ...data,
      updated_at: new Date(),
    };
    console.log('‚úÖ Profile updated in memory');
    return inMemoryProfiles[index];
  }

  try {
    const updates: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    Object.entries(data).forEach(([key, value]) => {
      if (key !== 'id' && key !== 'created_at' && key !== 'updated_at') {
        updates.push(`${key} = $${paramIndex}`);
        values.push(value);
        paramIndex++;
      }
    });

    if (updates.length === 0) {
      console.log('‚ö†Ô∏è No fields to update');
      return await getProfileById(id);
    }

    updates.push(`updated_at = CURRENT_TIMESTAMP`);
    values.push(id);

    console.log('üíæ Executing database update...');
    const query = `UPDATE profiles SET ${updates.join(', ')} WHERE id = $${paramIndex} RETURNING *`;
    const [profile] = await sql.unsafe<Profile[]>(query, values);
    
    if (profile) {
      console.log('‚úÖ Profile updated successfully in database:', profile.name);
    }
    return profile || null;
  } catch (error) {
    console.error('‚ùå Database error updating profile:', error);
    const index = inMemoryProfiles.findIndex(p => p.id === id);
    if (index === -1) return null;
    
    inMemoryProfiles[index] = {
      ...inMemoryProfiles[index],
      ...data,
      updated_at: new Date(),
    };
    return inMemoryProfiles[index];
  }
}

export async function deleteProfile(id: number): Promise<boolean> {
  console.log(`üóëÔ∏è Deleting profile ID: ${id}`);
  
  if (!sql) {
    const index = inMemoryProfiles.findIndex(p => p.id === id);
    if (index === -1) return false;
    inMemoryProfiles.splice(index, 1);
    console.log('‚úÖ Profile deleted from memory');
    return true;
  }

  try {
    await sql`DELETE FROM profiles WHERE id = ${id}`;
    console.log('‚úÖ Profile deleted from database');
    return true;
  } catch (error) {
    console.error('‚ùå Database error deleting profile:', error);
    return false;
  }
}

// Calendar event operations
export async function getCalendarEvents(profileId: number): Promise<CalendarEvent[]> {
  if (!sql) {
    return inMemoryEvents.filter(e => e.profile_id === profileId);
  }

  try {
    const events = await sql<CalendarEvent[]>`
      SELECT * FROM calendar_events 
      WHERE profile_id = ${profileId} 
      ORDER BY start_time DESC
    `;
    return events;
  } catch (error) {
    console.error('‚ùå Database error fetching events:', error);
    return inMemoryEvents.filter(e => e.profile_id === profileId);
  }
}

export async function saveCalendarEvent(event: Omit<CalendarEvent, 'id' | 'created_at'>): Promise<CalendarEvent> {
  console.log('üìÖ Saving calendar event:', event.title);
  
  if (!sql) {
    const newEvent: CalendarEvent = {
      ...event,
      id: nextEventId++,
      created_at: new Date(),
    };
    inMemoryEvents.push(newEvent);
    return newEvent;
  }

  try {
    console.log('üíæ Inserting calendar event into database...');
    const [savedEvent] = await sql<CalendarEvent[]>`
      INSERT INTO calendar_events (
        profile_id, event_id, title, description, start_time, end_time, attendees, source
      ) VALUES (
        ${event.profile_id}, ${event.event_id}, ${event.title}, ${event.description || null},
        ${event.start_time.toISOString()}, ${event.end_time.toISOString()},
        ${JSON.stringify(event.attendees || [])}, ${event.source}
      )
      ON CONFLICT (profile_id, event_id, source) 
      DO UPDATE SET
        title = EXCLUDED.title,
        description = EXCLUDED.description,
        start_time = EXCLUDED.start_time,
        end_time = EXCLUDED.end_time,
        attendees = EXCLUDED.attendees
      RETURNING *
    `;
    console.log('‚úÖ Event saved successfully in database with ID:', savedEvent.id);
    return savedEvent;
  } catch (error) {
    console.error('‚ùå Database error saving event:', error);
    const newEvent: CalendarEvent = {
      ...event,
      id: nextEventId++,
      created_at: new Date(),
    };
    inMemoryEvents.push(newEvent);
    return newEvent;
  }
}

// Token usage operations
export async function logTokenUsage(usage: Omit<TokenUsage, 'id' | 'created_at'>): Promise<TokenUsage> {
  console.log('üìä Logging token usage:', usage.operation_type, '-', usage.tokens_used, 'tokens');
  
  if (!sql) {
    const newUsage: TokenUsage = {
      ...usage,
      id: nextTokenId++,
      created_at: new Date(),
    };
    inMemoryTokens.push(newUsage);
    return newUsage;
  }

  try {
    console.log('üíæ Inserting token usage into database...');
    const [savedUsage] = await sql<TokenUsage[]>`
      INSERT INTO token_usage (profile_id, operation_type, tokens_used, lindy_agent_id)
      VALUES (${usage.profile_id}, ${usage.operation_type}, ${usage.tokens_used}, ${usage.lindy_agent_id || null})
      RETURNING *
    `;
    console.log('‚úÖ Token usage logged successfully in database');
    return savedUsage;
  } catch (error) {
    console.error('‚ùå Database error logging token usage:', error);
    const newUsage: TokenUsage = {
      ...usage,
      id: nextTokenId++,
      created_at: new Date(),
    };
    inMemoryTokens.push(newUsage);
    return newUsage;
  }
}

export async function getTokenUsage(profileId: number): Promise<TokenUsage[]> {
  if (!sql) {
    return inMemoryTokens.filter(t => t.profile_id === profileId);
  }

  try {
    const usage = await sql<TokenUsage[]>`
      SELECT * FROM token_usage 
      WHERE profile_id = ${profileId} 
      ORDER BY created_at DESC
    `;
    return usage;
  } catch (error) {
    console.error('‚ùå Database error fetching token usage:', error);
    return inMemoryTokens.filter(t => t.profile_id === profileId);
  }
}

export async function getTotalTokensByType(profileId: number): Promise<{
  agent_run: number;
  presales_report: number;
  slides_generation: number;
  total: number;
}> {
  if (!sql) {
    const tokens = inMemoryTokens.filter(t => t.profile_id === profileId);
    return {
      agent_run: tokens.filter(t => t.operation_type === 'agent_run').reduce((sum, t) => sum + t.tokens_used, 0),
      presales_report: tokens.filter(t => t.operation_type === 'presales_report').reduce((sum, t) => sum + t.tokens_used, 0),
      slides_generation: tokens.filter(t => t.operation_type === 'slides_generation').reduce((sum, t) => sum + t.tokens_used, 0),
      total: tokens.reduce((sum, t) => sum + t.tokens_used, 0),
    };
  }

  try {
    const [result] = await sql`
      SELECT 
        COALESCE(SUM(CASE WHEN operation_type = 'agent_run' THEN tokens_used ELSE 0 END), 0) as agent_run,
        COALESCE(SUM(CASE WHEN operation_type = 'presales_report' THEN tokens_used ELSE 0 END), 0) as presales_report,
        COALESCE(SUM(CASE WHEN operation_type = 'slides_generation' THEN tokens_used ELSE 0 END), 0) as slides_generation,
        COALESCE(SUM(tokens_used), 0) as total
      FROM token_usage
      WHERE profile_id = ${profileId}
    `;
    return result as any;
  } catch (error) {
    console.error('‚ùå Database error fetching token totals:', error);
    const tokens = inMemoryTokens.filter(t => t.profile_id === profileId);
    return {
      agent_run: tokens.filter(t => t.operation_type === 'agent_run').reduce((sum, t) => sum + t.tokens_used, 0),
      presales_report: tokens.filter(t => t.operation_type === 'presales_report').reduce((sum, t) => sum + t.tokens_used, 0),
      slides_generation: tokens.filter(t => t.operation_type === 'slides_generation').reduce((sum, t) => sum + t.tokens_used, 0),
      total: tokens.reduce((sum, t) => sum + t.tokens_used, 0),
    };
  }
}

// Initialize database on module load
if (sql) {
  console.log('Database initialized successfully');
} else {
  console.warn('‚ö†Ô∏è Database not configured - using in-memory storage');
}
